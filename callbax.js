#!/usr/bin/env node
// Generated by CoffeeScript 1.8.0
(function() {
  var Callbax,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  Callbax = (function() {
    Callbax.prototype.callback = null;

    Callbax.prototype.cleaners = null;

    Callbax.prototype.fn = null;

    function Callbax(callback) {
      this.callback = callback;
      this.split = __bind(this.split, this);
      this.pass = __bind(this.pass, this);
      this.next = __bind(this.next, this);
      this.functionize = __bind(this.functionize, this);
      this.error = __bind(this.error, this);
      this.done = __bind(this.done, this);
      this.cleanup = __bind(this.cleanup, this);
      if (typeof callback !== 'function') {
        throw new Error('callback function required');
      }
      this.cleaners = [];
      return this.fn = this.functionize(callback, (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return _this.done.apply(_this, args);
        };
      })(this));
    }

    Callbax.prototype.cleanup = function(fn) {
      if (typeof fn !== 'function') {
        throw new Error('handler function required');
      }
      return (this.cleaners != null ? this.cleaners : this.cleaners = []).push(fn);
    };

    Callbax.prototype.done = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args[0] != null) {
        return this.error.apply(this, args);
      } else {
        return this.callback.apply(this, args);
      }
    };

    Callbax.prototype.error = function() {
      var args, cleaner, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args[0] == null) {
        return false;
      }
      if (cleaner = (_ref = this.cleaners) != null ? _ref.pop() : void 0) {
        cleaner(args[0], (function(_this) {
          return function(stop_propagation) {
            if (!stop_propagation) {
              return _this.error.apply(_this, args);
            }
          };
        })(this));
      } else {
        this.callback.apply(this, args);
      }
      return true;
    };

    Callbax.prototype.functionize = function(source_fn, fn) {
      var key, value;
      for (key in source_fn) {
        value = source_fn[key];
        fn[key] = value;
      }
      fn.cleanup = this.cleanup;
      fn.error = this.error;
      fn.pass = this.pass;
      fn.next = this.next;
      fn.split = this.split;
      return fn;
    };

    Callbax.prototype.next = function(handler) {
      return new Callbax(this.functionize(this.fn, handler));
    };

    Callbax.prototype.pass = function(handler) {
      if (typeof handler !== 'function') {
        throw new Error('handler function required');
      }
      return this.functionize(this.fn, (function(_this) {
        return function() {
          var args, err;
          err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (!_this.error(err)) {
            return handler.apply(null, args);
          }
        };
      })(this));
    };

    Callbax.prototype.split = function() {
      var args, check_done, errored, handler, path_count, path_done, split_fn, split_fns, split_id, _i, _j, _len, _results;
      split_fns = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), handler = arguments[_i++];
      if (!split_fns.length) {
        throw new Error('split functions required');
      }
      if (typeof handler !== 'function') {
        throw new Error('split handler function required');
      }
      check_done = function() {
        var done, k, v;
        done = 0;
        for (k in path_done) {
          v = path_done[k];
          if (v) {
            done += 1;
          }
        }
        if (done === path_count) {
          return handler();
        }
      };
      path_count = split_fns.length;
      path_done = {};
      errored = false;
      _results = [];
      for (split_id = _j = 0, _len = split_fns.length; _j < _len; split_id = ++_j) {
        split_fn = split_fns[split_id];
        if (Array.isArray(split_fn)) {
          args = split_fn.slice(1);
          split_fn = split_fn[0];
        } else {
          args = [];
        }
        if (typeof split_fn !== 'function') {
          throw new Error('split_fn must be a function');
        }
        path_done[split_id] = 0;
        _results.push((function(_this) {
          return function(split_id) {
            return split_fn.apply(null, __slice.call(args).concat([new Callbax(_this.functionize(_this.fn, function(err) {
              if (!errored) {
                if (err) {
                  errored = true;
                  handler(err);
                }
                path_done[split_id] = 1;
                return check_done();
              }
            }))]));
          };
        })(this)(split_id));
      }
      return _results;
    };

    return Callbax;

  })();

  module.exports = function(callback) {
    return new Callbax(callback);
  };

}).call(this);
