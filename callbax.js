// Generated by CoffeeScript 1.9.0
(function() {
  var Callbax,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  Callbax = (function() {
    Callbax.prototype.callback = null;

    Callbax.prototype.cleaners = null;

    Callbax.prototype.fn = null;

    function Callbax(_at_callback) {
      this.callback = _at_callback;
      this.split = __bind(this.split, this);
      this.pass = __bind(this.pass, this);
      this.next = __bind(this.next, this);
      this.functionize = __bind(this.functionize, this);
      this.error = __bind(this.error, this);
      this.done = __bind(this.done, this);
      this.cleanup = __bind(this.cleanup, this);
      if (typeof this.callback !== 'function') {
        throw new Error('callback function required');
      }
      this.cleaners = [];
      return this.fn = this.functionize(this.callback, (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return _this.done.apply(_this, args);
        };
      })(this));
    }

    Callbax.prototype.cleanup = function(fn) {
      if (typeof fn !== 'function') {
        throw new Error('handler function required');
      }
      return (this.cleaners != null ? this.cleaners : this.cleaners = []).push(fn);
    };

    Callbax.prototype.done = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args[0] != null) {
        return this.error.apply(this, args);
      } else {
        return this.callback.apply(this, args);
      }
    };

    Callbax.prototype.error = function() {
      var args, cleaner, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args[0] == null) {
        return false;
      }
      if (cleaner = (_ref = this.cleaners) != null ? _ref.pop() : void 0) {
        cleaner(args[0], (function(_this) {
          return function(stop_propagation) {
            if (!stop_propagation) {
              return _this.error.apply(_this, args);
            }
          };
        })(this));
      } else {
        this.callback.apply(this, args);
      }
      return true;
    };

    Callbax.prototype.functionize = function(source_fn, fn) {
      var key, value;
      for (key in source_fn) {
        value = source_fn[key];
        fn[key] = value;
      }
      fn.cleanup = this.cleanup;
      fn.error = this.error;
      fn.pass = this.pass;
      fn.next = this.next;
      fn.split = this.split;
      return fn;
    };

    Callbax.prototype.next = function(handler) {
      return new Callbax(this.functionize(this.fn, handler));
    };

    Callbax.prototype.pass = function(handler) {
      if (typeof handler !== 'function') {
        throw new Error('handler function required');
      }
      return this.functionize(this.fn, (function(_this) {
        return function() {
          var args, err;
          err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          if (!_this.error(err)) {
            return handler.apply(null, args);
          }
        };
      })(this));
    };

    Callbax.prototype.split = function() {
      var args, check_done, errored, handler, path_count, path_done, split_fn, split_fns, split_id, _i, _j, _len, _results;
      split_fns = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), handler = arguments[_i++];
      if (typeof handler !== 'function') {
        throw new Error('split handler function required');
      }
      if (!split_fns.length) {
        handler(new Error('split functions required'));
      }
      check_done = function() {
        var done, v, _j, _len;
        done = 0;
        for (_j = 0, _len = path_done.length; _j < _len; _j++) {
          v = path_done[_j];
          if (v) {
            done += 1;
          }
        }
        if (done === path_count) {
          return handler(null, path_done);
        }
      };
      path_count = split_fns.length;
      path_done = [];
      errored = false;
      _results = [];
      for (split_id = _j = 0, _len = split_fns.length; _j < _len; split_id = ++_j) {
        split_fn = split_fns[split_id];
        if (Array.isArray(split_fn)) {
          args = split_fn.slice(1);
          split_fn = split_fn[0];
        } else {
          args = [];
        }
        if (typeof split_fn !== 'function') {
          throw new Error('split_fn must be a function');
        }
        path_done[split_id] = null;
        _results.push((function(_this) {
          return function(split_id) {
            return split_fn.apply(null, __slice.call(args).concat([new Callbax(_this.functionize(_this.fn, function() {
              var args, err, res;
              err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
              if (!errored) {
                if (err) {
                  errored = true;
                  return handler(err, []);
                }
                res = [];
                if (err !== void 0 || args.length) {
                  if (args.length) {
                    res.push.apply(res, [err].concat(__slice.call(args)));
                  } else {
                    res.push(err);
                  }
                }
                path_done[split_id] = res;
                return check_done();
              }
            }))]));
          };
        })(this)(split_id));
      }
      return _results;
    };

    return Callbax;

  })();

  module.exports = function(callback) {
    return new Callbax(callback);
  };

}).call(this);
